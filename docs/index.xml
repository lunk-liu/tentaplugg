<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TDDD38 tentaplugg #5</title>
    <link>https://lunk-liu.github.io/tentaplugg/</link>
    <description>Recent content on TDDD38 tentaplugg #5</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://lunk-liu.github.io/tentaplugg/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Project 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/project/project1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/project/project1/</guid>
      <description>asdasd</description>
    </item>
    
    <item>
      <title>Konstruktorer osv</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/klasser/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/klasser/</guid>
      <description>class String { public: using size_type = std::size_t; // nested type (alias declaration) String() = default; // default constructor, compiler generated String(const String&amp;amp;); // copy constructor String(String&amp;amp;&amp;amp;) noexcept ; // move constructor String(const char*); // type converting constructor, from C string ~String(); // destructor String&amp;amp; operator=(const String&amp;amp;) &amp;amp;; // copy assignment operator, ref-qualifier (lvalues only) String&amp;amp; operator=(String&amp;amp;&amp;amp;) &amp;amp; noexcept; // move assignment operator String&amp;amp; operator=(const char*) &amp;amp;; // type converting assignment operator size_type length() const; // const member function – accessor function // .</description>
    </item>
    
    <item>
      <title>Kort och gott</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/kort_och_gott/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/kort_och_gott/</guid>
      <description>rvalue The name rule: If it has a name it’s an lvalue, otherwise it&amp;rsquo;s a rvalue.
Constructor delegation Att en konstruktor utnytjar en annan konstruktor för att utföra sitt jobb. Tex Child(int x) : Parent{x} {};, eller String() : String{ &amp;quot;&amp;quot; } {};</description>
    </item>
    
    <item>
      <title>Todo</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/todo/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/todo/</guid>
      <description> Allt det här med konstruktorer i polymorfa klasshierkier template templates nöta in dynamic_cast och typeid, templateclass Policy&amp;gt;, nth_element, vad fan är r-value, l-value, r-value reference?  </description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170816/1/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170816/1/</guid>
      <description>&lt;p&gt;Give a reason for why the language needs the virtual keyword from a viewpoint of the zero overhead principle?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170816/2/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170816/2/</guid>
      <description>&lt;p&gt;The &lt;strong&gt;&amp;lt;functional&amp;gt;&lt;/strong&gt; header has a lot of function objects that implement simple operations such as &lt;strong&gt;std::less&lt;/strong&gt; implementing &lt;strong&gt;operator&amp;lt;&lt;/strong&gt;. Why do we need these function objects?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170816/3/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170816/3/</guid>
      <description>&lt;p&gt;Exceptions should be caught by reference. Give two reasons why.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170816/4/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170816/4/</guid>
      <description>Question: Suppose that we have a class C with an int member i with a constructor that initializes i with an int value (see below). A problem with this implementation is that we are also able to call this constructor with values that are convertible to int. Give the declarations needed in the class to give compilation errors when the constructor is called with values of type that is convertible to int (i.</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170816/5/</link>
      <pubDate>Wed, 16 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170816/5/</guid>
      <description>&lt;p&gt;What is the difference between the noexcept operator and the noexcept specifier?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170529/1/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170529/1/</guid>
      <description>&lt;p&gt;What does it mean that a type is contextually convertible to bool?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170529/2/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170529/2/</guid>
      <description>&lt;p&gt;A function-try-block is sometimes good when defining constructors. Why are they especially
good in that use-case?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170529/3/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170529/3/</guid>
      <description>&lt;p&gt;In a template parameter type declaration, you can use &lt;strong&gt;typename&lt;/strong&gt; or &lt;strong&gt;class&lt;/strong&gt;. Does it matter which one you use?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170529/4/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170529/4/</guid>
      <description>Why should one avoid to specialize a function template? What is the, often better, alter- native?
Answer: Because of function call overload rules. A template function will never have its arguments converted by the compiler to match the call. A normal function overload is often better:
// primary template template &amp;lt;typename T&amp;gt; void fun(T t) { ... } // specialization for int, will not be called with types // convertible to int such as short and long template&amp;lt;&amp;gt; void fun&amp;lt;int&amp;gt;(int t) { .</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170529/5/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170529/5/</guid>
      <description>&lt;p&gt;In which situation would one chose to declare a destructor pure virtual?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170420/1/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170420/1/</guid>
      <description>&lt;p&gt;Given the following snippet of code, give a reason for having the using declaration on line
4 instead of qualifying the call on line 5 (i.e. return &lt;strong&gt;std::begin(range)&lt;/strong&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;typename Range &amp;gt;
auto iter( Range &amp;amp;&amp;amp; range )
{
    using std :: begin ;
    return begin ( range ); // line 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170420/2/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170420/2/</guid>
      <description>&lt;p&gt;Given the following primary template declaration, give a declaration of a specialization of
&lt;strong&gt;foo&lt;/strong&gt; for type &lt;strong&gt;char&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt;
struct foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170420/3/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170420/3/</guid>
      <description>&lt;p&gt;Assuming v is a &lt;strong&gt;std::vector&amp;lt;int&amp;gt;&lt;/strong&gt;, why is the following code wrong?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static_assert (v.size () &amp;gt; 0, &amp;quot; vector is empty !&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170420/4/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170420/4/</guid>
      <description>Assume you have definitions for the following functions:
void fun(int , short ); void fun(int , double );  The call fun(2,3) will give an ambiguous overload. Why?
Answer: The problem is (of course) due to type conversions. An int can be implicitly converted to both double and short and both will give possible loss of precision.</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170420/5/</link>
      <pubDate>Thu, 20 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170420/5/</guid>
      <description>&lt;p&gt;Describe what length below does and give a valid example of a call to length.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;typename ... Args &amp;gt;
int length (Args &amp;amp;&amp;amp; ... args)
{
    return sizeof ...( args );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170112/1/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170112/1/</guid>
      <description>&lt;p&gt;The standard library has a function &lt;strong&gt;std::addressof&lt;/strong&gt; that is used in generic code to find
the address of an object. Usually, the &lt;strong&gt;operator &amp;amp;&lt;/strong&gt; is used for finding addresses of objects,
why do you think they added a function as well?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170112/2/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170112/2/</guid>
      <description>&lt;p&gt;A forwarding reference and an r-value reference are declared in the same way (&lt;strong&gt;Type &amp;amp;&amp;amp;&lt;/strong&gt;),
but are semantically very different. Why?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170112/3/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170112/3/</guid>
      <description>&lt;p&gt;C++14 added generic lambdas. Give an example of a generic lambda and give a definition
of a function object class that is equivalent to the compiler-generated closure object created
by your lambda.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/170112/4/</link>
      <pubDate>Thu, 12 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/170112/4/</guid>
      <description>&lt;p&gt;Why shouldn’t you use &lt;strong&gt;operator&amp;lt;&lt;/strong&gt; when comparing iterators in the code below (container
is some sort of STL container):
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160817/1/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160817/1/</guid>
      <description>&lt;p&gt;Consider the following function. Why is this interface a bad design? (hint, think about ownership&amp;hellip;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;X* compute( /*some args*/ ) {
    X* res = new X{};
    // do something with res 
    return res;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160817/2/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160817/2/</guid>
      <description>&lt;p&gt;What is meant by the keyword constexpr and why is it sometimes needed?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160817/3/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160817/3/</guid>
      <description>&lt;p&gt;Give some short code example showing why it is important to always do member initialization in declaration order in a member initializer list.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160817/4/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160817/4/</guid>
      <description>&lt;p&gt;Consider the following class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class X {
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declare a user-defined conversion function to convert &lt;strong&gt;X&lt;/strong&gt; into &lt;strong&gt;int&lt;/strong&gt; as a member function.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160817/5/</link>
      <pubDate>Wed, 17 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160817/5/</guid>
      <description>&lt;p&gt;Give an example of a class that can be passed to the function foo below:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template&amp;lt;typename T, typename U, template&amp;lt;typename, typename&amp;gt; class Container&amp;gt;
void foo(Container&amp;lt;T,U&amp;gt; const &amp;amp;) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160602/1/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160602/1/</guid>
      <description>&lt;p&gt;Give one code example of where the compiler uses ADL for name lookup.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160602/2/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160602/2/</guid>
      <description>&lt;p&gt;Give, with either text or a short (1-5 simple statements each) code example, two examples of undefined behavior.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160602/3/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160602/3/</guid>
      <description>&lt;p&gt;Why should you prefer usage of the free function &lt;code&gt;std::begin&lt;/code&gt; instead of using the member function?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160602/4/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160602/4/</guid>
      <description>&lt;p&gt;What is the difference between implementation defined behavior and undefined behavior?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160602/5/</link>
      <pubDate>Thu, 02 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160602/5/</guid>
      <description>&lt;p&gt;What is meant by the zero-overhead rule?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 1</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/1/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/1/</guid>
      <description>&lt;p&gt;Given the following declarations, explain why the call &lt;code&gt;max(i,d)&lt;/code&gt; will give an error. Make a possible fix in the call to make it compile.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; 
T max(T, T);

int i; 
double d ;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 2</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/2/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/2/</guid>
      <description>&lt;p&gt;In C++, it is possible to create an unnamed namespace. What is an unnamed namespace and what is it used for?
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 3</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/3/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/3/</guid>
      <description>&lt;p&gt;Give two different uses of the keyword &lt;code&gt;mutable&lt;/code&gt; and describe the effect of &lt;code&gt;mutable&lt;/code&gt; in each case.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 4</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/4/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/4/</guid>
      <description>&lt;p&gt;Give two ways of supplying the compiler with implicit type conversion to or from a user-defined type.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fråga 5</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/5/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/5/</guid>
      <description>&lt;p&gt;Give an example of a delegating constructor.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Programmeringsuppgift 6</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/assignment6/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/assignment6/</guid>
      <description>Submit your solution as Assignment #6 The game Yahtzee is based on throwing five dice and trying to get specific combinations of these dice. In this assignment, you are going to implement a part of the scoring mechanism.
There are a lot of possible combinations that gives points in Yahtzee, but in this exercise we are going to support checking for a number of ones, number of twos and one pair (two dice with the same result) in a given set of dice.</description>
    </item>
    
    <item>
      <title>Programmeringsuppgift 7</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/assignment7/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/assignment7/</guid>
      <description>Copy the file given_files/assignment7.cc to your working directory and make changes to your copy. Submit your answer as Assignment #7.
There is a function that works a bit like the standard algorithm std::find (but much simpler).
int * Find(int * start, int * end, int val) { for ( auto it = start; it != end; ++it ) { if ( *it == val ) { return it; } } } return end; // wasn&#39;t found  Your task is to do the following modifications to the given function so that the commented lines in the given code compile and give output according to the comments.</description>
    </item>
    
    <item>
      <title>Programmeringsuppgift 8</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/assignment8/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/assignment8/</guid>
      <description>Write your code in a file named assignment8.cc and submit your answer as Assignment #8.
In this assignment, you’re supposed to show good knowledge of the standard library. Any usage of standard iteration statements will give point deductions. In each step of your solution, make sure to use the algorithm most suited to solve the task – for_each is not a valid solution for all problems.
Here is a model competitive programming exercise for you to solve according to the algo- rithm presented after the problem text.</description>
    </item>
    
    <item>
      <title>Programmeringsuppgift 9</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/160331/assignment9/</link>
      <pubDate>Thu, 31 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/160331/assignment9/</guid>
      <description>Copy the file given_files/assignment9.cc to your working directory and make changes to that file. Submit your answer as Assignment #9.
This task is divided into two parts, the first giving three of the total five points and the second is worth the two remaining points. You are not supposed to give separate solutions for the two parts, but may stop after implementing the first part.
Your task in this assignment is to create a stream output manipulator to format a container for printing to some ostream.</description>
    </item>
    
  </channel>
</rss>