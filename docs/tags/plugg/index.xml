<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Plugg on TDDD38 tentaplugg #5</title>
    <link>https://lunk-liu.github.io/tentaplugg/tags/plugg/</link>
    <description>Recent content in Plugg on TDDD38 tentaplugg #5</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://lunk-liu.github.io/tentaplugg/tags/plugg/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Konstruktorer osv</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/klasser/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/klasser/</guid>
      <description>class String { public: using size_type = std::size_t; // nested type (alias declaration) String() = default; // default constructor, compiler generated String(const String&amp;amp;); // copy constructor String(String&amp;amp;&amp;amp;) noexcept ; // move constructor String(const char*); // type converting constructor, from C string ~String(); // destructor String&amp;amp; operator=(const String&amp;amp;) &amp;amp;; // copy assignment operator, ref-qualifier (lvalues only) String&amp;amp; operator=(String&amp;amp;&amp;amp;) &amp;amp; noexcept; // move assignment operator String&amp;amp; operator=(const char*) &amp;amp;; // type converting assignment operator size_type length() const; // const member function – accessor function // .</description>
    </item>
    
    <item>
      <title>Kort och gott</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/kort_och_gott/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/kort_och_gott/</guid>
      <description>rvalue The name rule: If it has a name it’s an lvalue, otherwise it&amp;rsquo;s a rvalue.
Constructor delegation Att en konstruktor utnytjar en annan konstruktor för att utföra sitt jobb. Tex Child(int x) : Parent{x} {};, eller String() : String{ &amp;quot;&amp;quot; } {};</description>
    </item>
    
    <item>
      <title>Polymorfism</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/polymorfism/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/polymorfism/</guid>
      <description>/* * Person.h */ #ifndef PERSON_H #define PERSON_H #include &amp;quot;CRN.h&amp;quot; #include &amp;lt;iosfwd&amp;gt; #include &amp;lt;string&amp;gt; namespace IDA_Person { class Person { public: virtual ~Person() = default; virtual Person* clone() const = 0; virtual std::string str() const { return name_ + &#39; &#39; + crn_.str(); } std::string get_name() const { return name_; } void set_name(const std::string&amp;amp; name) { name_ = name; } CRN get_crn() const { return crn_; } void set_crn(const CRN&amp;amp; crn) { crn_ = crn; } protected: Person(const std::string&amp;amp; name, const CRN&amp;amp; crn) : name_{ name }, crn_{ crn } {}; Person(const Person&amp;amp;) = default; Person(Person &amp;amp;&amp;amp;) = default; private: Person&amp;amp; operator=(const Person&amp;amp;) = delete; std::string name_; CRN crn_; }; std::ostream&amp;amp; operator&amp;lt;&amp;lt;(std::ostream&amp;amp;, const Person&amp;amp;); } // namespace IDA_Person #endif  </description>
    </item>
    
    <item>
      <title>Todo</title>
      <link>https://lunk-liu.github.io/tentaplugg/post/plugga/todo/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lunk-liu.github.io/tentaplugg/post/plugga/todo/</guid>
      <description> Allt det här med konstruktorer i polymorfa klasshierkier template templates nöta in dynamic_cast och typeid, templateclass Policy&amp;gt;, nth_element, vad fan är r-value, l-value, r-value reference?  </description>
    </item>
    
  </channel>
</rss>